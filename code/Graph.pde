 class Graph{
  ArrayList<Circle> circles;
  float hookeConst;
  float coulombConst;
  float dampingRatio;
  float timeStepsize;
  float totalKinetic;
  float threshold;
  float minMass;
  float maxMass;
  Circle selectedCirle;
  Circle toConnectedCircle;
  Circle connectedCircle;
  HashSet<Integer> lockedCircles;
  
  // constructor
  Graph(ArrayList<Circle> circles) {
    this.circles = circles;
    this.hookeConst = 0.4;
    this.coulombConst= 100.0;
    this.dampingRatio = 0.5;
    this.timeStepsize = 0.5;
    this.totalKinetic = MAX_FLOAT;
    this.threshold = 0.15;
    this.selectedCirle = null;
    this.toConnectedCircle = null;
    this.connectedCircle = null;
    this.minMass = MAX_FLOAT;
    this.maxMass = MIN_FLOAT;
    this.lockedCircles = new HashSet<Integer>();
  }
  
  // initialize a random position for each circle on the canvas
  void initializeCirclesLocations() {
    for (Circle c : this.circles) {
      if (c.mass > maxMass) {
        this.maxMass = c.mass;
      }
      if (c.mass < minMass) {
        this.minMass = c.mass;
      }
    }
    float longerSide = max(width, height);
    for (Circle c : this.circles){
      // map circle's diameter based on their mass
      c.d = map(c.mass, this.minMass, this.maxMass, longerSide/40, longerSide/10);
      c.x = random(40, width - 40);
      c.y = random(40, height - 40);
    }
  }
  
  // update circles positions and return the current kinetic energy
  float updateCirclesLocations() {
    float currKinetic = 0;
    
    for (int i = 0; i < this.circles.size(); i++) {
      Circle curCircle = this.circles.get(i);
      if (this.lockedCircles.contains(curCircle.id)) continue;
      if (this.selectedCirle != null && curCircle.id == this.selectedCirle.id) {
        continue;
      }
      float fx = 0;
      float fy = 0;
      
      // Hooke's force created by current circle's neighbors
      for (Map.Entry<Circle, Float> entry : curCircle.neighbors.entrySet()) {
        Circle neighbor = entry.getKey();
        float springLength = entry.getValue();
        float dx = neighbor.x - curCircle.x;
        float dy = neighbor.y - curCircle.y;
        float dis = sqrt(dx * dx + dy * dy) + 0.1;
        fx += this.hookeConst * (dx - springLength*dx/dis);
        fy += this.hookeConst * (dy - springLength*dy/dis);
      }
      
      // Coulomb's force generated by all other circles on current circle
      for (int j = 0; j < this.circles.size(); j++) {
        Circle tmp = this.circles.get(j);
        if (tmp.id != curCircle.id) {
          float xDis =  curCircle.x - tmp.x;
          float yDis = curCircle.y - tmp.y;
          float dis = xDis * xDis + yDis * yDis + 0.1;
          fx += this.coulombConst * (xDis/dis);
          fy += this.coulombConst * (yDis/dis);
        }
      }
      
      // update circle location
      float ax = fx / curCircle.mass;
      float ay = fy / curCircle.mass;
       
      float vx = this.dampingRatio * (curCircle.vX + this.timeStepsize * ax);
      float vy = this.dampingRatio * (curCircle.vY + this.timeStepsize * ax);
       
      float dx = curCircle.x + this.timeStepsize * vx + 0.5 * ax * (this.timeStepsize * this.timeStepsize);
      float dy = curCircle.y + this.timeStepsize * vy + 0.5 * ay * (this.timeStepsize * this.timeStepsize);
      
      float r = curCircle.d * 0.5;

     // check canvas boundaries
      if(dx < r) {
        dx = r;
      } else if(dx > width - r) {
        dx =  width - r;
      }
      if(dy < r) {
        dy = r;
      } else if(dy > height - r) {
        dy =  height - r;
      }

      // update circles' locations
      curCircle.x = dx;
      curCircle.y = dy;
 
      curCircle.vX = vx;
      curCircle.vY = vy;     
      float currV = sqrt(vx * vx + vy * vy);
      currKinetic += curCircle.mass * pow(currV, 2);
    }   
    return currKinetic;
  }
  
  void drawGraph() {
    
    if (this.totalKinetic > this.threshold) {
      this.totalKinetic = this.updateCirclesLocations();
    }
    strokeWeight(2);
    
    this.drawEdges();
    
    for (Circle c : this.circles) {
      c.drawCircle();
    }
    
    drawNewEdge();
    
    fill(0, 0, 0);
    textAlign(LEFT, TOP);
    textSize(12);
    text("Total Kinetic Energy: " + this.totalKinetic, 10, 10);
    text("Kinetic Energy Threshold: " + this.threshold, 10, 30);
    text("Spring Constant: " + this.hookeConst, 10, 50);
    text("Coulomb Constant: " + this.coulombConst, 10, 70);
    text("Damping Coefficient: " + this.dampingRatio, 10, 90);
    text("Time Step: " + this.timeStepsize, 10, 110);
    
    textAlign(LEFT, BOTTOM);
    textSize(12);
    fill(151, 152, 153);
    text("Right clcik to add or remove circle.", 10, height - 70);
    text("Shift + Left click to connect two circles.", 10, height - 50);
    text("Double click to lock a circle.", 10, height - 30);
  }

  void drawEdges(){
    stroke(96, 142, 234);
    for (Circle c : this.circles) {
      for (Map.Entry<Circle, Float> entry : c.neighbors.entrySet()) {
        Circle neighbor = entry.getKey();
        line(c.x, c.y, neighbor.x, neighbor.y);  
      }
    }
  }
  
  void mouseMovedListener(float x, float y){
    for(Circle c : this.circles) {
      if (c.intersected(x, y)) {
        c.isHighlighted = true; 
      } else {
        c.isHighlighted = false;
      }
    }
  }
  
  void mousePressedListener(float x, float y) {
    for(Circle c : this.circles) {
      if (c.intersected(x, y)) {
        this.selectedCirle = c; 
      }
    }
  }
  
  void mouseDraggedListener(float x, float y) {
    if (this.selectedCirle == null) return;
    float r = this.selectedCirle.d/2;
    if (x > width - r) {
      this.selectedCirle.x = width - r;
    } else if (x < r) {
      this.selectedCirle.x = r;
    } else {
      this.selectedCirle.x = x;
    }
    
    if (y > height - r) {
      this.selectedCirle.y = height;
    } else if (y < r) {
      this.selectedCirle.y = r;
    } else {
      this.selectedCirle.y = y;
    }
    this.totalKinetic = this.updateCirclesLocations();
  }
  
  void mouseReleasedListener() {
    if (this.selectedCirle != null) {
      this.selectedCirle.isHighlighted = false;
      this.selectedCirle = null;
    }
  }
  
  void addNewCircle(float x, float y) {
    int removeIndex = -1;
    Circle removeCirle = null;
    for(int i = 0; i < this.circles.size(); i++) {
      if (this.circles.get(i).intersected(x, y)) {
        removeIndex = i;
        removeCirle = this.circles.get(i); 
        //return;
      }
    }
    if (removeIndex != -1) {
      this.circles.remove(removeIndex);
      //return;
    }
    
    if (removeCirle != null) {
      for (Map.Entry<Circle, Float> entry : removeCirle.neighbors.entrySet()) {
        Circle neighbor = entry.getKey();
        neighbor.neighbors.remove(removeCirle);
      }
      
      this.totalKinetic = this.updateCirclesLocations();
      return;
    }
    
    int newId = this.circles.size() + 1;
    float newMass = round(random(this.minMass, this.maxMass));
    Circle newC = new Circle(newId, newMass);
    newC.x= mouseX;
    newC.y = mouseY;
    float longerSide = max(width, height);
    newC.d = map(newC.mass, this.minMass, this.maxMass, longerSide/40, longerSide/10);
    this.circles.add(newC);
    
    this.totalKinetic = this.updateCirclesLocations();
  }
  
  
  void connectCircles(float x, float y) {
    if (toConnectedCircle == null) {
      for(int i = 0; i < this.circles.size(); i++) {
        if (this.circles.get(i).intersected(x, y)) {
          toConnectedCircle = this.circles.get(i);
        }
      }
    } else {
      for(int i = 0; i < this.circles.size(); i++) {
        if (this.circles.get(i).intersected(x, y)) {
          if (this.circles.get(i).id != toConnectedCircle.id) {
            connectedCircle = this.circles.get(i);
          }
        }
      }
    }
  }
  
  void drawNewEdge() {
    if (toConnectedCircle == null) return;
    if (connectedCircle == null) {
      line(toConnectedCircle.x, toConnectedCircle.y, mouseX, mouseY);
    } else {
      float springLen = dist(toConnectedCircle.x, toConnectedCircle.y, connectedCircle.x, connectedCircle.y);
      toConnectedCircle.neighbors.put(connectedCircle, springLen/2);
      connectedCircle.neighbors.put(toConnectedCircle, springLen/2);
      this.totalKinetic = this.updateCirclesLocations();
      toConnectedCircle = null;
      connectedCircle = null;
    }
  }
  
  void randomConstant() {
    this.hookeConst = random(0.1, 2);
    this.coulombConst= random(50, 250);
    this.dampingRatio = random(0.3, 0.8);
    this.timeStepsize = random(0.3, 0.8);
    for (Circle c : this.circles) {
      c.locked = false;
    }
    this.lockedCircles = new HashSet<Integer>();
    this.initializeCirclesLocations();
    this.totalKinetic = this.updateCirclesLocations();
  }
  
  void lockCircle(float x, float y) {
     for (Circle c : this.circles) {
       if (c.intersected(x, y)) {
         if (this.lockedCircles.contains(c.id)) {
           this.lockedCircles.remove(c.id);
           c.locked = false;
         } else {
           this.lockedCircles.add(c.id);
           c.locked = true;
         }
       }
     }
  }
  
}